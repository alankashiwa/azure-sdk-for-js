## API Report File for "@azure/maps-creator"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

import * as coreAuth from '@azure/core-auth';
import * as coreClient from '@azure/core-client';
import * as coreRestPipeline from '@azure/core-rest-pipeline';
import { PollerLike } from '@azure/core-lro';
import { PollOperationState } from '@azure/core-lro';

// @public
export interface Alias {
    readonly aliasId?: string;
    readonly createdTimestamp?: Date;
    readonly creatorDataItemId?: string;
    readonly lastUpdatedTimestamp?: Date;
}

// @public
export interface AliasAssignOptionalParams extends coreClient.OperationOptions {
}

// @public
export type AliasAssignResponse = Alias;

// @public
export interface AliasCreateHeaders {
    accessControlExposeHeaders?: string;
}

// @public
export interface AliasCreateOptionalParams extends coreClient.OperationOptions {
    creatorDataItemId?: string;
}

// @public
export type AliasCreateResponse = AliasCreateHeaders & Alias;

// @public
export interface AliasDeleteOptionalParams extends coreClient.OperationOptions {
}

// @public
export interface AliasGetOptionalParams extends coreClient.OperationOptions {
}

// @public
export type AliasGetResponse = Alias;

// @public
export interface AliasListNextOptionalParams extends coreClient.OperationOptions {
}

// @public
export type AliasListNextResponse = AliasListResult;

// @public
export interface AliasListOptionalParams extends coreClient.OperationOptions {
}

// @public
export type AliasListResponse = AliasListResult;

// @public
export interface AliasListResult {
    readonly aliases?: Alias[];
    readonly nextLink?: string;
}

// @public
export interface AliasOperations {
    assign(aliasId: string, creatorDataItemId: string, options?: AliasAssignOptionalParams): Promise<AliasAssignResponse>;
    create(options?: AliasCreateOptionalParams): Promise<AliasCreateResponse>;
    delete(aliasId: string, options?: AliasDeleteOptionalParams): Promise<void>;
    get(aliasId: string, options?: AliasGetOptionalParams): Promise<AliasGetResponse>;
    list(options?: AliasListOptionalParams): Promise<AliasListResponse>;
    listNext(nextLink: string, options?: AliasListNextOptionalParams): Promise<AliasListNextResponse>;
}

// @public
export interface BooleanRule {
    false?: string;
    true?: string;
}

// @public
export type BooleanStyleRule = StyleRule & {
    type: "boolean";
    rules: BooleanRule[];
};

// @public
export interface BufferRequestBody {
    distances?: number[];
    geometries?: Record<string, unknown>;
}

// @public
export interface BufferResult {
    features?: GeoJsonFeatureCollection;
    readonly summary?: BufferSummary;
}

// @public (undocumented)
export interface BufferSummary {
    readonly information?: string;
    readonly udid?: string;
}

// @public
export interface ClosestPoint {
    readonly distanceInMeters?: number;
    readonly geometryId?: string;
    position?: LatLongPairAbbreviated;
}

// @public
export interface ClosestPointResponse {
    result?: ClosestPoint[];
    readonly summary?: ClosestPointSummary;
}

// @public
export interface ClosestPointSummary {
    readonly information?: string;
    sourcePoint?: LatLongPairAbbreviated;
    readonly udid?: string;
}

// @public (undocumented)
export interface Collection {
    description?: string;
    links: WFSEndpointLink[];
    name: string;
    readonly ontology?: string;
    title?: string;
}

// @public
export interface CollectionDefinition {
    description?: string;
    featureTypes: string[];
    geometryType: GeoJsonGeometryType;
    idPrefix: string;
    links?: WFSEndpointLink[];
    name: string;
    readonly ontology?: string;
    properties?: DefinitionProperty[];
    title?: string;
}

// @public (undocumented)
export interface CollectionsResponse {
    collections: Collection[];
    links: WFSEndpointLink[];
    readonly ontology?: string;
}

// @public (undocumented)
export interface ConformanceResult {
    conformsTo: string[];
}

// @public
export interface Conversion {
    readonly conversionId?: string;
    readonly created?: string;
    readonly description?: string;
    readonly featureCounts?: {
        [propertyName: string]: number;
    };
    readonly ontology?: string;
    readonly udid?: string;
}

// @public
export interface ConversionConvertHeaders {
    resourceLocation?: string;
}

// @public
export interface ConversionConvertOptionalParams extends coreClient.OperationOptions {
    description?: string;
    resumeFrom?: string;
    updateIntervalInMs?: number;
}

// @public
export type ConversionConvertResponse = ConversionConvertHeaders & LongRunningOperationResult;

// @public
export interface ConversionDeleteOptionalParams extends coreClient.OperationOptions {
}

// @public
export interface ConversionGetOperationHeaders {
    resourceLocation?: string;
}

// @public
export interface ConversionGetOperationOptionalParams extends coreClient.OperationOptions {
}

// @public
export type ConversionGetOperationResponse = ConversionGetOperationHeaders & LongRunningOperationResult;

// @public
export interface ConversionGetOptionalParams extends coreClient.OperationOptions {
}

// @public
export type ConversionGetResponse = Conversion;

// @public
export interface ConversionListNextOptionalParams extends coreClient.OperationOptions {
}

// @public
export type ConversionListNextResponse = ConversionListResult;

// @public
export interface ConversionListOptionalParams extends coreClient.OperationOptions {
}

// @public
export type ConversionListResponse = ConversionListResult;

// @public
export interface ConversionListResult {
    readonly conversions?: Conversion[];
    readonly nextLink?: string;
}

// @public
export interface ConversionOperations {
    beginConvert(udid: string, outputOntology: OutputOntology, options?: ConversionConvertOptionalParams): Promise<PollerLike<PollOperationState<ConversionConvertResponse>, ConversionConvertResponse>>;
    beginConvertAndWait(udid: string, outputOntology: OutputOntology, options?: ConversionConvertOptionalParams): Promise<ConversionConvertResponse>;
    delete(conversionId: string, options?: ConversionDeleteOptionalParams): Promise<void>;
    get(conversionId: string, options?: ConversionGetOptionalParams): Promise<ConversionGetResponse>;
    getOperation(operationId: string, options?: ConversionGetOperationOptionalParams): Promise<ConversionGetOperationResponse>;
    list(options?: ConversionListOptionalParams): Promise<ConversionListResponse>;
    listNext(nextLink: string, options?: ConversionListNextOptionalParams): Promise<ConversionListNextResponse>;
}

// Warning: (ae-forgotten-export) The symbol "GeneratedClientContext" needs to be exported by the entry point index.d.ts
// Warning: (ae-internal-missing-underscore) The name "CreatorClient" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal (undocumented)
export class CreatorClient extends GeneratedClientContext {
    constructor(credentials: coreAuth.TokenCredential, options?: GeneratedClientOptionalParams);
    // (undocumented)
    aliasOperations: AliasOperations;
    // (undocumented)
    conversionOperations: ConversionOperations;
    // (undocumented)
    data: Data;
    // (undocumented)
    datasetOperations: DatasetOperations;
    // (undocumented)
    featureStateOperations: FeatureStateOperations;
    // (undocumented)
    spatial: Spatial;
    // (undocumented)
    tilesetOperations: TilesetOperations;
    // (undocumented)
    wfs: Wfs;
}

// @public
export interface Data {
    beginUpdate(udid: string, updateContent: Record<string, unknown>, options?: DataUpdateOptionalParams): Promise<PollerLike<PollOperationState<DataUpdateResponse>, DataUpdateResponse>>;
    beginUpdateAndWait(udid: string, updateContent: Record<string, unknown>, options?: DataUpdateOptionalParams): Promise<DataUpdateResponse>;
    beginUpload(...args: [
        DataFormat,
        "application/octet-stream",
        coreRestPipeline.RequestBodyType,
        DataUpload$binaryOptionalParams?
    ] | [
        DataFormat,
        "application/json",
        Record<string, unknown>,
        DataUpload$jsonOptionalParams?
    ]): Promise<PollerLike<PollOperationState<DataUploadResponse>, DataUploadResponse>>;
    beginUploadAndWait(...args: [
        DataFormat,
        "application/octet-stream",
        coreRestPipeline.RequestBodyType,
        DataUpload$binaryOptionalParams?
    ] | [
        DataFormat,
        "application/json",
        Record<string, unknown>,
        DataUpload$jsonOptionalParams?
    ]): Promise<DataUploadResponse>;
    delete(udid: string, options?: DataDeleteOptionalParams): Promise<void>;
    download(udid: string, options?: DataDownloadOptionalParams): Promise<DataDownloadResponse>;
    getOperation(operationId: string, options?: DataGetOperationOptionalParams): Promise<DataGetOperationResponse>;
    list(options?: DataListOptionalParams): Promise<DataListResponse>;
}

// @public
export interface DataDeleteOptionalParams extends coreClient.OperationOptions {
}

// @public
export interface DataDownloadHeaders {
    contentType?: string;
}

// @public
export interface DataDownloadOptionalParams extends coreClient.OperationOptions {
}

// @public
export type DataDownloadResponse = DataDownloadHeaders & {
    blobBody?: Promise<Blob>;
    readableStreamBody?: NodeJS.ReadableStream;
};

// @public
export type DataFormat = string;

// @public
export interface DataGetOperationHeaders {
    resourceLocation?: string;
}

// @public
export interface DataGetOperationOptionalParams extends coreClient.OperationOptions {
}

// @public
export type DataGetOperationResponse = DataGetOperationHeaders & LongRunningOperationResult;

// @public
export interface DataListOptionalParams extends coreClient.OperationOptions {
}

// @public
export type DataListResponse = MapDataListResult;

// @public
export interface Dataset {
    readonly created?: Date;
    readonly datasetId?: string;
    datasetSources?: DatasetSources;
    readonly description?: string;
    readonly featureCounts?: Record<string, unknown>;
    readonly ontology?: string;
}

// @public
export interface DatasetCreateHeaders {
    resourceLocation?: string;
}

// @public
export interface DatasetCreateOptionalParams extends coreClient.OperationOptions {
    datasetId?: string;
    description?: string;
    resumeFrom?: string;
    updateIntervalInMs?: number;
}

// @public
export type DatasetCreateResponse = DatasetCreateHeaders & LongRunningOperationResult;

// @public
export interface DatasetDeleteOptionalParams extends coreClient.OperationOptions {
}

// @public
export interface DatasetGetOperationHeaders {
    resourceLocation?: string;
}

// @public
export interface DatasetGetOperationOptionalParams extends coreClient.OperationOptions {
}

// @public
export type DatasetGetOperationResponse = DatasetGetOperationHeaders & LongRunningOperationResult;

// @public
export interface DatasetGetOptionalParams extends coreClient.OperationOptions {
}

// @public
export type DatasetGetResponse = Dataset;

// @public
export interface DatasetListNextOptionalParams extends coreClient.OperationOptions {
}

// @public
export type DatasetListNextResponse = DatasetListResult;

// @public
export interface DatasetListOptionalParams extends coreClient.OperationOptions {
}

// @public
export type DatasetListResponse = DatasetListResult;

// @public
export interface DatasetListResult {
    readonly datasets?: Dataset[];
    readonly nextLink?: string;
}

// @public
export interface DatasetOperations {
    beginCreate(conversionId: string, options?: DatasetCreateOptionalParams): Promise<PollerLike<PollOperationState<DatasetCreateResponse>, DatasetCreateResponse>>;
    beginCreateAndWait(conversionId: string, options?: DatasetCreateOptionalParams): Promise<DatasetCreateResponse>;
    delete(datasetId: string, options?: DatasetDeleteOptionalParams): Promise<void>;
    get(datasetId: string, options?: DatasetGetOptionalParams): Promise<DatasetGetResponse>;
    getOperation(operationId: string, options?: DatasetGetOperationOptionalParams): Promise<DatasetGetOperationResponse>;
    list(options?: DatasetListOptionalParams): Promise<DatasetListResponse>;
    listNext(nextLink: string, options?: DatasetListNextOptionalParams): Promise<DatasetListNextResponse>;
}

// @public
export interface DatasetSources {
    readonly appendDatasetId?: string;
    readonly conversionIds?: string[];
}

// @public
export interface DataUpdateHeaders {
    resourceLocation?: string;
}

// @public
export interface DataUpdateOptionalParams extends coreClient.OperationOptions {
    description?: string;
    resumeFrom?: string;
    updateIntervalInMs?: number;
}

// @public
export type DataUpdateResponse = DataUpdateHeaders & LongRunningOperationResult;

// @public
export interface DataUpload$binaryOptionalParams extends coreClient.OperationOptions {
    description?: string;
    resumeFrom?: string;
    updateIntervalInMs?: number;
}

// @public
export interface DataUpload$jsonOptionalParams extends coreClient.OperationOptions {
    description?: string;
    resumeFrom?: string;
    updateIntervalInMs?: number;
}

// @public
export interface DataUploadHeaders {
    resourceLocation?: string;
}

// @public
export type DataUploadResponse = DataUploadHeaders & LongRunningOperationResult;

// @public (undocumented)
export interface DefinitionProperty {
    name: string;
    required: boolean;
    type: Record<string, unknown>;
}

// @public
export interface ErrorAdditionalInfo {
    readonly info?: Record<string, unknown>;
    readonly type?: string;
}

// @public
export interface ErrorDetail {
    readonly additionalInfo?: ErrorAdditionalInfo[];
    readonly code?: string;
    readonly details?: ErrorDetail[];
    readonly message?: string;
    readonly target?: string;
}

// @public
export interface ErrorResponse {
    error?: ErrorDetail;
}

// @public
export type ExtendedGeoJsonFeatureCollection = GeoJsonFeatureCollectionData & ExtendedGeoJsonFeatureCollectionData & {
    type?: GeoJsonObjectType;
};

// @public (undocumented)
export interface ExtendedGeoJsonFeatureCollectionData {
    links?: WFSEndpointLink[];
    numberReturned?: number;
    readonly ontology?: string;
}

// @public (undocumented)
export interface FeatureResult {
    feature: GeoJsonFeature;
    links?: WFSEndpointLink[];
    readonly ontology?: string;
}

// @public
export interface FeatureState {
    eventTimestamp?: string;
    keyName?: string;
    value?: string;
}

// @public
export interface FeatureStateCreateStatesetOptionalParams extends coreClient.OperationOptions {
    description?: string;
}

// @public
export type FeatureStateCreateStatesetResponse = StatesetCreatedResult;

// @public
export interface FeatureStateDeleteStateOptionalParams extends coreClient.OperationOptions {
}

// @public
export interface FeatureStateDeleteStatesetOptionalParams extends coreClient.OperationOptions {
}

// @public
export interface FeatureStateGetStatesetOptionalParams extends coreClient.OperationOptions {
}

// @public
export type FeatureStateGetStatesetResponse = Stateset;

// @public
export interface FeatureStateListStatesetsNextOptionalParams extends coreClient.OperationOptions {
}

// @public
export type FeatureStateListStatesetsNextResponse = StatesetListResult;

// @public
export interface FeatureStateListStatesetsOptionalParams extends coreClient.OperationOptions {
}

// @public
export type FeatureStateListStatesetsResponse = StatesetListResult;

// @public
export interface FeatureStateListStatesOptionalParams extends coreClient.OperationOptions {
}

// @public
export type FeatureStateListStatesResponse = FeatureStatesStructure;

// @public
export interface FeatureStateOperations {
    createStateset(datasetId: string, styleRules: StyleRules, options?: FeatureStateCreateStatesetOptionalParams): Promise<FeatureStateCreateStatesetResponse>;
    deleteState(statesetId: string, featureId: string, keyName: string, options?: FeatureStateDeleteStateOptionalParams): Promise<void>;
    deleteStateset(statesetId: string, options?: FeatureStateDeleteStatesetOptionalParams): Promise<void>;
    getStateset(statesetId: string, options?: FeatureStateGetStatesetOptionalParams): Promise<FeatureStateGetStatesetResponse>;
    listStates(statesetId: string, featureId: string, options?: FeatureStateListStatesOptionalParams): Promise<FeatureStateListStatesResponse>;
    listStatesets(options?: FeatureStateListStatesetsOptionalParams): Promise<FeatureStateListStatesetsResponse>;
    listStatesetsNext(nextLink: string, options?: FeatureStateListStatesetsNextOptionalParams): Promise<FeatureStateListStatesetsNextResponse>;
    updateStates(statesetId: string, featureId: string, featureStates: FeatureStatesStructure, options?: FeatureStateUpdateStatesOptionalParams): Promise<void>;
    updateStateset(statesetId: string, styleRules: StyleRules, options?: FeatureStateUpdateStatesetOptionalParams): Promise<void>;
}

// @public
export interface FeatureStatesStructure {
    states?: FeatureState[];
}

// @public
export interface FeatureStateUpdateStatesetOptionalParams extends coreClient.OperationOptions {
}

// @public
export interface FeatureStateUpdateStatesOptionalParams extends coreClient.OperationOptions {
}

// @public
export interface GeneratedClientOptionalParams extends coreClient.ServiceClientOptions {
    clientId?: string;
    endpoint?: string;
    geography?: Geography;
}

// @public
export interface Geofence {
    readonly expiredGeofenceGeometryId?: string[];
    readonly geometries?: GeofenceGeometry[];
    readonly invalidPeriodGeofenceGeometryId?: string[];
    readonly isEventPublished?: boolean;
}

// @public
export interface GeofenceGeometry {
    readonly deviceId?: string;
    readonly distance?: number;
    readonly geometryId?: string;
    readonly nearestElevation?: number;
    readonly nearestLat?: number;
    readonly nearestLon?: number;
    readonly udid?: string;
}

// @public
export type GeofenceMode = string;

// @public
export type GeographicResourceLocation = string;

// @public
export type Geography = string;

// @public
export type GeoJsonFeature = GeoJsonObject & GeoJsonFeatureData & {
    type: "Feature";
};

// @public
export type GeoJsonFeatureCollection = GeoJsonObject & GeoJsonFeatureCollectionData & {
    type: "FeatureCollection";
};

// @public (undocumented)
export interface GeoJsonFeatureCollectionData {
    features: GeoJsonFeature[];
}

// @public (undocumented)
export interface GeoJsonFeatureData {
    featureType?: string;
    geometry: GeoJsonGeometryUnion;
    id?: string;
    properties?: Record<string, unknown>;
}

// @public
export type GeoJsonGeometry = GeoJsonObject & {
    type: "GeoJsonGeometry" | "Point" | "MultiPoint" | "LineString" | "MultiLineString" | "Polygon" | "MultiPolygon" | "GeometryCollection";
};

// @public
export type GeoJsonGeometryCollection = GeoJsonGeometry & GeoJsonGeometryCollectionData & {};

// @public (undocumented)
export interface GeoJsonGeometryCollectionData {
    geometries: GeoJsonGeometryUnion[];
}

// @public
export type GeoJsonGeometryType = string;

// @public (undocumented)
export type GeoJsonGeometryUnion = GeoJsonGeometry | GeoJsonPoint | GeoJsonMultiPoint | GeoJsonLineString | GeoJsonMultiLineString | GeoJsonPolygon | GeoJsonMultiPolygon | GeoJsonGeometryCollection;

// @public
export type GeoJsonLineString = GeoJsonGeometry & GeoJsonLineStringData & {};

// @public (undocumented)
export interface GeoJsonLineStringData {
    coordinates: number[][];
}

// @public
export type GeoJsonMultiLineString = GeoJsonGeometry & GeoJsonMultiLineStringData & {};

// @public (undocumented)
export interface GeoJsonMultiLineStringData {
    coordinates: number[][][];
}

// @public
export type GeoJsonMultiPoint = GeoJsonGeometry & GeoJsonMultiPointData & {};

// @public
export interface GeoJsonMultiPointData {
    coordinates: number[][];
}

// @public
export type GeoJsonMultiPolygon = GeoJsonGeometry & GeoJsonMultiPolygonData & {};

// @public (undocumented)
export interface GeoJsonMultiPolygonData {
    coordinates: number[][][][];
}

// @public
export interface GeoJsonObject {
    type: "GeoJsonGeometry" | "Feature" | "FeatureCollection" | "Point" | "MultiPoint" | "LineString" | "MultiLineString" | "Polygon" | "MultiPolygon" | "GeometryCollection";
}

// @public
export type GeoJsonObjectType = "Point" | "MultiPoint" | "LineString" | "MultiLineString" | "Polygon" | "MultiPolygon" | "GeometryCollection" | "Feature" | "FeatureCollection";

// @public (undocumented)
export type GeoJsonObjectUnion = GeoJsonObject | GeoJsonGeometryUnion | GeoJsonFeature | GeoJsonFeatureCollection;

// @public
export type GeoJsonPoint = GeoJsonGeometry & GeoJsonPointData & {};

// @public
export interface GeoJsonPointData {
    coordinates: number[];
}

// @public
export type GeoJsonPolygon = GeoJsonGeometry & GeoJsonPolygonData & {};

// @public (undocumented)
export interface GeoJsonPolygonData {
    coordinates: number[][][];
}

// @public
export interface GreatCircleDistanceResult {
    readonly result?: GreatCircleDistanceResultResult;
    readonly summary?: GreatCircleDistanceSummary;
}

// @public
export interface GreatCircleDistanceResultResult {
    readonly distanceInMeters?: number;
}

// @public
export interface GreatCircleDistanceSummary {
    sourcePoint?: LatLongPairAbbreviated;
    targetPoint?: LatLongPairAbbreviated;
}

// @public
export type JsonFormat = string;

// @public
export enum KnownDataFormat {
    DwgZipPackage = "dwgzippackage",
    Geojson = "geojson",
    Zip = "zip"
}

// @public
export enum KnownGeofenceMode {
    All = "All",
    EnterAndExit = "EnterAndExit"
}

// @public
export enum KnownGeographicResourceLocation {
    Eu = "eu",
    Us = "us"
}

// @public
export enum KnownGeography {
    // (undocumented)
    Eu = "eu",
    // (undocumented)
    Us = "us"
}

// @public
export enum KnownGeoJsonGeometryType {
    GeoJsonGeometryCollection = "GeometryCollection",
    GeoJsonLineString = "LineString",
    GeoJsonMultiLineString = "MultiLineString",
    GeoJsonMultiPoint = "MultiPoint",
    GeoJsonMultiPolygon = "MultiPolygon",
    GeoJsonPoint = "Point",
    GeoJsonPolygon = "Polygon"
}

// @public
export enum KnownJsonFormat {
    Json = "json"
}

// @public
export enum KnownLroStatus {
    Failed = "Failed",
    NotStarted = "NotStarted",
    Running = "Running",
    Succeeded = "Succeeded"
}

// @public
export enum KnownOutputOntology {
    Facility20 = "facility-2.0"
}

// @public
export enum KnownStyleRuleType {
    Boolean = "boolean",
    Number = "number",
    String = "string"
}

// @public (undocumented)
export interface LandingPageResult {
    links: WFSEndpointLink[];
    readonly ontology?: string;
}

// @public
export interface LatLongPairAbbreviated {
    lat?: number;
    lon?: number;
}

// @public
export interface LongRunningOperationResult {
    readonly created?: Date;
    error?: ErrorDetail;
    operationId?: string;
    readonly status?: LroStatus;
    warning?: ErrorDetail;
}

// @public
export type LroStatus = string;

// @public
export interface MapData {
    // (undocumented)
    dataFormat?: DataFormat;
    readonly description?: string;
    readonly locationURL?: string;
    readonly sizeInBytes?: number;
    readonly udid?: string;
    readonly uploadStatus?: UploadStatus;
}

// @public
export interface MapDataListResult {
    readonly mapDataList?: MapData[];
}

// @public
export interface NumberRule {
    color?: string;
    range?: Range;
}

// @public
export type NumberStyleRule = StyleRule & {
    type: "number";
    rules: NumberRule[];
};

// @public
export type OutputOntology = string;

// @public
export interface PointInPolygonResult {
    result?: PointInPolygonResultResult;
    readonly summary?: PointInPolygonSummary;
}

// @public
export interface PointInPolygonResultResult {
    readonly intersectingGeometries?: string[];
    readonly isPointInPolygons?: boolean;
}

// @public
export interface PointInPolygonSummary {
    readonly information?: string;
    sourcePoint?: LatLongPairAbbreviated;
    readonly udid?: string;
}

// @public
export interface Position {
    latitude: number;
    longitude: number;
}

// @public
export interface Range {
    exclusiveMaximum?: string;
    exclusiveMinimum?: string;
    maximum?: string;
    minimum?: string;
}

// @public
export interface Spatial {
    evaluatePointInPolygon(format: JsonFormat, udid: string, position: Position, options?: SpatialEvaluatePointInPolygonOptionalParams): Promise<SpatialEvaluatePointInPolygonResponse>;
    getBuffer(format: JsonFormat, udid: string, distances: string, options?: SpatialGetBufferOptionalParams): Promise<SpatialGetBufferResponse>;
    getClosestPoint(format: JsonFormat, udid: string, position: Position, options?: SpatialGetClosestPointOptionalParams): Promise<SpatialGetClosestPointResponse>;
    getGeofence(format: JsonFormat, deviceId: string, udid: string, position: Position, options?: SpatialGetGeofenceOptionalParams): Promise<SpatialGetGeofenceResponse>;
    getGreatCircleDistance(format: JsonFormat, query: string, options?: SpatialGetGreatCircleDistanceOptionalParams): Promise<SpatialGetGreatCircleDistanceResponse>;
    postBuffer(format: JsonFormat, bufferRequestBody: BufferRequestBody, options?: SpatialPostBufferOptionalParams): Promise<SpatialPostBufferResponse>;
    postClosestPoint(format: JsonFormat, closestPointRequestBody: Record<string, unknown>, position: Position, options?: SpatialPostClosestPointOptionalParams): Promise<SpatialPostClosestPointResponse>;
    postGeofence(format: JsonFormat, deviceId: string, searchGeofenceRequestBody: Record<string, unknown>, position: Position, options?: SpatialPostGeofenceOptionalParams): Promise<SpatialPostGeofenceResponse>;
    postPointInPolygon(format: JsonFormat, pointInPolygonRequestBody: Record<string, unknown>, position: Position, options?: SpatialPostPointInPolygonOptionalParams): Promise<SpatialPostPointInPolygonResponse>;
}

// @public
export interface SpatialEvaluatePointInPolygonOptionalParams extends coreClient.OperationOptions {
}

// @public
export type SpatialEvaluatePointInPolygonResponse = PointInPolygonResult;

// @public
export interface SpatialGetBufferOptionalParams extends coreClient.OperationOptions {
}

// @public
export type SpatialGetBufferResponse = BufferResult;

// @public
export interface SpatialGetClosestPointOptionalParams extends coreClient.OperationOptions {
    numberOfClosestPoints?: number;
}

// @public
export type SpatialGetClosestPointResponse = ClosestPointResponse;

// @public
export interface SpatialGetGeofenceHeaders {
    xCorrelationId?: string;
}

// @public
export interface SpatialGetGeofenceOptionalParams extends coreClient.OperationOptions {
    altitude?: number;
    isAsync?: boolean;
    mode?: GeofenceMode;
    searchBufferInMeters?: number;
    userTime?: Date;
}

// @public
export type SpatialGetGeofenceResponse = SpatialGetGeofenceHeaders & Geofence;

// @public
export interface SpatialGetGreatCircleDistanceOptionalParams extends coreClient.OperationOptions {
}

// @public
export type SpatialGetGreatCircleDistanceResponse = GreatCircleDistanceResult;

// @public
export interface SpatialPostBufferOptionalParams extends coreClient.OperationOptions {
}

// @public
export type SpatialPostBufferResponse = BufferResult;

// @public
export interface SpatialPostClosestPointOptionalParams extends coreClient.OperationOptions {
    numberOfClosestPoints?: number;
}

// @public
export type SpatialPostClosestPointResponse = ClosestPointResponse;

// @public
export interface SpatialPostGeofenceHeaders {
    xCorrelationId?: string;
}

// @public
export interface SpatialPostGeofenceOptionalParams extends coreClient.OperationOptions {
    altitude?: number;
    isAsync?: boolean;
    mode?: GeofenceMode;
    searchBuffer?: number;
    userTime?: Date;
}

// @public
export type SpatialPostGeofenceResponse = SpatialPostGeofenceHeaders & Geofence;

// @public
export interface SpatialPostPointInPolygonOptionalParams extends coreClient.OperationOptions {
}

// @public
export type SpatialPostPointInPolygonResponse = PointInPolygonResult;

// @public
export interface Stateset {
    datasetIds?: string[];
    readonly description?: string;
    styleRules?: StyleRules;
}

// @public
export interface StatesetCreatedResult {
    readonly statesetId?: string;
}

// @public
export type StatesetInfo = Stateset & {
    readonly statesetId?: string;
};

// @public
export interface StatesetListResult {
    readonly nextLink?: string;
    statesets?: StatesetInfo[];
}

// @public
export type StringStyleRule = StyleRule & {
    type: "string";
    rules: {
        [propertyName: string]: string;
    }[];
};

// @public
export interface StyleRule {
    keyName: string;
    type: "boolean" | "number" | "string";
}

// @public
export interface StyleRules {
    styleRules?: StyleRuleUnion[];
}

// @public
export type StyleRuleType = string;

// @public (undocumented)
export type StyleRuleUnion = StyleRule | BooleanStyleRule | NumberStyleRule | StringStyleRule;

// @public
export interface Tileset {
    readonly bbox?: number[];
    readonly datasetId?: string;
    readonly description?: string;
    readonly maxZoom?: number;
    readonly minZoom?: number;
    readonly ontology?: string;
    readonly tilesetId?: string;
}

// @public
export interface TilesetCreateHeaders {
    resourceLocation?: string;
}

// @public
export interface TilesetCreateOptionalParams extends coreClient.OperationOptions {
    description?: string;
    resumeFrom?: string;
    updateIntervalInMs?: number;
}

// @public
export type TilesetCreateResponse = TilesetCreateHeaders & LongRunningOperationResult;

// @public
export interface TilesetDeleteOptionalParams extends coreClient.OperationOptions {
}

// @public
export interface TilesetGetOperationHeaders {
    resourceLocation?: string;
}

// @public
export interface TilesetGetOperationOptionalParams extends coreClient.OperationOptions {
}

// @public
export type TilesetGetOperationResponse = TilesetGetOperationHeaders & LongRunningOperationResult;

// @public
export interface TilesetGetOptionalParams extends coreClient.OperationOptions {
}

// @public
export type TilesetGetResponse = Tileset;

// @public
export interface TilesetListNextOptionalParams extends coreClient.OperationOptions {
}

// @public
export type TilesetListNextResponse = TilesetListResult;

// @public
export interface TilesetListOptionalParams extends coreClient.OperationOptions {
}

// @public
export type TilesetListResponse = TilesetListResult;

// @public
export interface TilesetListResult {
    readonly nextLink?: string;
    readonly tilesets?: Tileset[];
}

// @public
export interface TilesetOperations {
    beginCreate(datasetId: string, options?: TilesetCreateOptionalParams): Promise<PollerLike<PollOperationState<TilesetCreateResponse>, TilesetCreateResponse>>;
    beginCreateAndWait(datasetId: string, options?: TilesetCreateOptionalParams): Promise<TilesetCreateResponse>;
    delete(tilesetId: string, options?: TilesetDeleteOptionalParams): Promise<void>;
    get(tilesetId: string, options?: TilesetGetOptionalParams): Promise<TilesetGetResponse>;
    getOperation(operationId: string, options?: TilesetGetOperationOptionalParams): Promise<TilesetGetOperationResponse>;
    list(options?: TilesetListOptionalParams): Promise<TilesetListResponse>;
    listNext(nextLink: string, options?: TilesetListNextOptionalParams): Promise<TilesetListNextResponse>;
}

// @public
export type UploadStatus = "Pending" | "Completed" | "Failed";

// @public
export interface Wfs {
    deleteFeature(datasetId: string, collectionId: string, featureId: string, options?: WfsDeleteFeatureOptionalParams): Promise<void>;
    getCollection(datasetId: string, collectionId: string, options?: WfsGetCollectionOptionalParams): Promise<WfsGetCollectionResponse>;
    getCollectionDefinition(datasetId: string, collectionId: string, options?: WfsGetCollectionDefinitionOptionalParams): Promise<WfsGetCollectionDefinitionResponse>;
    getCollections(datasetId: string, options?: WfsGetCollectionsOptionalParams): Promise<WfsGetCollectionsResponse>;
    getFeature(datasetId: string, collectionId: string, featureId: string, options?: WfsGetFeatureOptionalParams): Promise<WfsGetFeatureResponse>;
    getFeatures(datasetId: string, collectionId: string, options?: WfsGetFeaturesOptionalParams): Promise<WfsGetFeaturesResponse>;
    getLandingPage(datasetId: string, options?: WfsGetLandingPageOptionalParams): Promise<WfsGetLandingPageResponse>;
    listConformance(datasetId: string, options?: WfsListConformanceOptionalParams): Promise<WfsListConformanceResponse>;
}

// @public
export interface WfsDeleteFeatureOptionalParams extends coreClient.OperationOptions {
}

// @public
export interface WFSEndpointLink {
    href: string;
    hrefLang?: string;
    rel?: string;
    title?: string;
    type?: string;
}

// @public
export interface WfsGetCollectionDefinitionOptionalParams extends coreClient.OperationOptions {
}

// @public
export type WfsGetCollectionDefinitionResponse = CollectionDefinition;

// @public
export interface WfsGetCollectionOptionalParams extends coreClient.OperationOptions {
}

// @public
export type WfsGetCollectionResponse = Collection;

// @public
export interface WfsGetCollectionsOptionalParams extends coreClient.OperationOptions {
}

// @public
export type WfsGetCollectionsResponse = CollectionsResponse;

// @public
export interface WfsGetFeatureOptionalParams extends coreClient.OperationOptions {
}

// @public
export type WfsGetFeatureResponse = FeatureResult;

// @public
export interface WfsGetFeaturesOptionalParams extends coreClient.OperationOptions {
    boundingBox?: number[];
    filter?: string;
    limit?: number;
}

// @public
export type WfsGetFeaturesResponse = ExtendedGeoJsonFeatureCollection;

// @public
export interface WfsGetLandingPageOptionalParams extends coreClient.OperationOptions {
}

// @public
export type WfsGetLandingPageResponse = LandingPageResult;

// @public
export interface WfsListConformanceOptionalParams extends coreClient.OperationOptions {
}

// @public
export type WfsListConformanceResponse = ConformanceResult;


// (No @packageDocumentation comment for this package)

```
